{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}

    <h1>Report</h1>

    <div class="report-nav">
        <a class="report-navlink" href="#kmom01">Kmom01</a>
        <a class="report-navlink" href="#kmom02">Kmom02</a>
        <a class="report-navlink" href="#kmom03">Kmom03</a>
        <a class="report-navlink" href="#kmom04">Kmom04</a>
        <a class="report-navlink" href="#kmom05">Kmom05</a>
        <a class="report-navlink" href="#kmom06">Kmom06</a>
        <a class="report-navlink-project" href="#projekt">Projekt</a>
    </div>

    <h2 class="report-rubric" id="kmom01">Kmom01</h2>
    <div class="report-container">

<p>Har tidigare jobbat med ett objektorienterat fokus i oopython-kursen, så känner mig hyggligt
varm och bekväm i kläderna på ett konceptuellt plan.</p>

<p>Och det handlar ju, som så ofta programmeringspråken emellan, om liknande konstruktioner kring samma
centrala datatyper och koncept som går igen.</p>

<p>En klass definierar strukturen för en objekttyp, både dess properties, i.e värdevariabler, och metoder,
i.e de specifika funktioner som är knutna till klassen och dess objekt.</p>

<p>Utifrån den klassen kan man sedan "skapa", instansiera, ett objekt, där all data och all funktionalitet,
alltså alla dess properties och klasspecifika metoder, finns samlade att tillgå i objektet.</p>

<p>Ett mycket vanligt sätt att jobba är att även etablera en konstruktor, en standardiserad grundmetod, (__magisk metod), som tillåter en att
skicka med argument i instansierandet för att kunna tillskriva objektets properties värden direkt i samband med skapandet.</p>

<p>Det är också i regel rekommenderat att tänka aktivt kring vilka delar av objektets properties och metoder som behöver och ska vara tillgängliga
för en användare, vilket man manipulerar med nyckelorden public, private och protected.</p>

<p>Vanligtvis rekommenderas man att sätta alla properties till private som default, och att man istället reglerar det sättet
som en användare kan interagera med objektets data med publika metoder, där två väldigt vanliga varianter är set och get.</p>

<p>När jag överblickar kodbasen som ligger till grund för våran första kmom01-version av symfony-bygget,
så har jag lite tudelade känslor.</p>

<p>Det har gått smidigt, och det har varit trevligt, att komma igång och jobba med ramverket,
men kan samtidigt känna att det upplevs som aningen bloated, speciellt i relation till våra hittills väldigt modesta sidor.</p>

<p>Har på ett personligt plan en rätt så stark minimalistisk ådra, så det är väl någonting som instinktivt skaver lite där.</p>

<p>Samtidigt har jag förstått att väldigt mycket, om inte den absoluta majoriteten, av den webbutveckling
som man kommer att möta ute i arbetslivet kretsar kring arbete i olika typer av ramverk, så det är nyttigt och viktigt
att bekanta sig med dem, och det ska bli intressant att se om och hur ens uppfattning och förståelse
kommer evolvera under kursens gång i arbetet med exemplet i Symfony.</p>

<p>PHP - The Right Way verkar vara en väldigt lovande resurs. Förefaller vara ovanligt kärnfull, insiktsfull och välskriven.</p>

<p>The Basics-sektionen är utmärkt, bokmärkt, och redan läst ett par gånger.</p>

<p>De kortfattade och klara redogörelserna för programparadigmen och namespaces, samt sektionen kring säkerhet,
var några delar som stod ut vid den första genomläsningen.</p>

<p>Mitt TIL, eller TWIL, är hur verkligt gediget man tycks kunna arbeta i php på ett objektorienterat sätt,
trots att det i relativa termer tillkom relativt sent "på riktigt", med riktigt seriös funktionalitet, i PHP 5.0 (2004) (läser jag innantill).
</p>

<p>Nåja, har ändå passerat tjugo år sedan dess, så kanske bättre uttryckt: imponerande ändå för ett språk som till en början saknade den objektrelaterade orienteringen.</p>

<p>MVH</p>

</div>




    <h2 class="report-rubric" id="kmom02">Kmom02</h2>
    <div class="report-container">

    <p>Ett arv handlar om "är en"/"is a"-förhållande klasser emellan, med en föräldraklass/superklass som
    barnklasser/subklasser först ärver grund-egenskaperna/metoderna ifrån, och därefter utökas/modifieras/specificeras ytterligare.
    </p>

    <p>
    I php görs det med nyckelordet extends, och för att illustrera det tar jag in ett exempel från min implementation,
    där subklassen DeckOfCards52 först ärver sin grundstruktur från superklassen DeckOfCards. Därefter plockas jokrarna bort,
    för att tillgängliggöra en användbar, spelbar kortlek: </p>

    <blockquote class="code-example">
    <pre>

        class DeckOfCards52 extends DeckOfCards
        {
            public function __construct()
            {
                parent::__construct();

                $this->removeJokers();
            }

        private function removeJokers(): void
        {
            $this->cards = array_filter($this->cards, function ($card) {
                return $card->getCardAsInt() !== 0;
            });

            $this->cards = array_values($this->cards);
        }
        }


    </pre>
    </blockquote>






    <p>Komposition handlar istället om ett har en/består av-förhållande, där en klass innehåller
    instanser av en eller flera klasser. Ett DeckOfCards (eller dess subklass DeckOfCards52) i mitt exempel
    består av 54 (52) Card-instanser.
    </p>

    <p> Traits är ett smidigt, men lösare, typ utav arv som frångår den vanliga arvhierarkin,
    som tillåter en klass att "låna" in funktionalitet från flera källor, att anamma flera "traits",
    vilket inte hade varit möjligt med en vanlig inheritance-syntax då php inte har stöd för
    multipelt arv.
    </p>

    <p>
    Det ger dessutom en flexibilitet
    och mångsidighet, och är på många sätt att föredra framför klassiskt multipelt arv som det finns stöd för i
    andra språk, som är bunden och begränsad av en mer rigid klasshierarki.
    <p>

    <p>Interface är en sinnrik konstruktion, som i någon mening snor på ordningen, och istället definerar och
    stipulerar vad för funktionalitet (vilka metoder) som ska finnas, och lämnar det upp till
    utvecklaren själv att lösa det.</p>

    <p>
    För ett exempel-gränssnitt (interface) som kräver printColor()-funktionalitet, så skulle en klass
    som implementerar det kunna se ut såhär:

    <blockquote class="code-example">
    <pre>
    interface InterfaceColor
    {
        public function printColor();
    }

    class Coffee implements InterfaceColor
    {
        const COLOR = "Black";
        public function printColor()
        {
            return self::COLOR;
        }
    }

    </p>
    </pre>
    </blockquote>
    </p>


    <p>Känner mig tillfreds med den klass-struktur jag fått på plats, och tror att den kommer visa
    sig någorlunda duglig att bygga fungerande, enklare spellogik kring, vilket stundar i nästa kursmoment.
    </p>

    <p>Valde att också lägga till en cardInt-property i Card-klassen, som kanske kan visa sig vara aningen överflödig,
    då det den åstadkommer redan borde kunna täckas av cardSuit och cardRank, men tänkte att det eventuellt
    skulle kunna visa sig vara värdefullt att ha tillgång till en int-property som är unik för varje kort.
    </p>

    <p>Kombinationen (cardSuit, cardRank) är ju redan unik, för att använda mig av SQL-klingande terminologi,
    men det är ju ändå bara en litet, modest ytterligare property, så den fick hänga med.</p>

    <p>Hade till en början bara $hand som en vanlig array-property innehållandes Card(s) i min Player-klass, och tänkte
    att det preliminärt skulle kunna vara tillräckligt, men gjorde det ordentligt och omstrukturerade och konstruerade en ordentlig
    CardHand-klass istället som en Player istället får inneha.</p>

    <p>Just nu ges ett ess cardRank = 14, vilket inte är helt riktigt, då det också
    kan vara = 1 i t ex en lägre stege i ett pokerexempel. Ämnar justera det på något bra sätt i
    nästa kursmoment när jag är igång med spellogiken.</p>

    <p>Huvudspåret är att främst använda mig av kortens Unicode-representation när jag ska visa upp korten
    i min spelimplementation, men finns även en enklare cardValue-property att tillgå.</p>

    <p>Arbetet med Symfony flyter på fint, och när man nu väl är igång och jobbar med den givna
    controller/route/template-strukturen så går det ju väldigt enkelt och smidigt att skapa nya routes
    och vyer.</p>

    <p>
    Etablerade även en enklare ytterligare LightDarkThemeController som fick hantera skiftandet mellan det mörka och det ljusa temat.
    </p>

    <p>
    Inte någon exemplarisk modulär struktur på css-koden hittills, men fungerar fint, och jobbar samlat vidare
    i app.css, och har etablerat en kompletterande app-dark-theme.css som läses in (efter app.css) i det fallet
    att det mörka temat är applicerat.
    </p>

    <p>
    Känns ovant att skriva commits i den form som rekommenderas i artikeln, men ska testa på det ordentligt
    nästa kursmoment och verkligen försöka anamma den mer enhetliga, tydliga strukturen.
    </p>

    <p>
    Ett utav många TIL/*TWIL är hur smidig och tacksam session-hanteringen är med den SessionInterface som
    Symfony tillhandahåller.
    </p>

    <p>
    MVH
    </p>


    </div>


    <h2 class="report-rubric" id="kmom03">KMOM03</h2>

    <p>Redovisningstext</p>

    <br><br><br><br><br><br><br><br>


    <h2 class="report-rubric" id="kmom04">KMOM04</h2>

    <p>Redovisningstext</p>

    <br><br><br><br><br><br><br><br>



    <h2 class="report-rubric" id="kmom05">KMOM05</h2>

    <p>Redovisningstext</p>

    <br><br><br><br><br><br><br><br>


    <h2 class="report-rubric" id="kmom06">KMOM06</h2>

    <p>Redovisningstext</p>

    <br><br><br><br><br><br><br><br>


    <h2 class="report-rubric" id="projekt">Projekt</h2>

    <p>Redovisningstext</p>

    <br><br><br><br><br><br><br><br>


{% endblock %}